<html>

  <head>
    <title>Untitled</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://unpkg.com/@stencila/thema@1/dist/themes/stencila/styles.css"
      rel="stylesheet">
    <script src="https://unpkg.com/@stencila/thema@1/dist/themes/stencila/index.js"
      type="text/javascript"></script>
    <script
      src="https://unpkg.com/@stencila/components@&lt;=1/dist/stencila-components/stencila-components.esm.js"
      type="module"></script>
    <script
      src="https://unpkg.com/@stencila/components@&lt;=1/dist/stencila-components/stencila-components.js"
      type="text/javascript"></script>
  </head>

  <body>
    <article itemtype="https://schema.org/Article" itemscope="true">
      <h1 itemprop="headline">Untitled</h1>
      <h1 id="-jupyter-notebook-codec"><code>ipynb</code>: Jupyter Notebook codec</h1>
      <p>The <code>ipynb</code> codec is for decoding and encoding Jupyter Notebook&#39;s
        <code>nbformat</code> JSON. Jupyter Notebooks were formally known as IPython Notebooks, and
        correspondingly, usually having the <code>ipynb</code> filename extension.</p>
      <blockquote>
        <p>This codec is under development. It requires updating to the revised schemas for
          <code>CodeChunk</code>s in the <a
            href="https://github.com/stencila/schema/pull/132/files"><code>execution-engines</code>
            branch of <code>stencila/schema</code></a> e.g. addition of <code>errors</code>
          property. See the TODO:s in the code.</p>
      </blockquote>
      <h2 id="typings">Typings</h2>
      <p>This codec uses Typescript type definitions for <code>nbformat</code> versions
        <code>v3</code> and <code>v4</code> that are generated from the <code>nbformat</code> JSON
        schema definitions in the <a
          href="https://github.com/jupyter/nbformat/">https://github.com/jupyter/nbformat/</a>
        repository. See <a href="nbformat.js"><code>nbformat.js</code></a> for more details.</p>
      <p>These type definitions are used to improve type safety when encoding and decoding. We use
        the type names e.g. <code>MarkdownCell</code> in the documentation below.</p>
      <h2 id="decoding-3">Decoding</h2>
      <p>Prior to decoding the contents of the notebook is validated against the
        <code>nbformat</code> JSON Schema version determined by the <code>nbformat</code> property
        of the notebook. All notebooks are decoded to a <code>Article</code>.</p>
      <h3 id="metadata">Metadata</h3>
      <p>The only metadata specified in the <code>nbformat</code> JSON schema are <code>title</code>
        and <code>authors</code>, although arbitrary metadata can be added to a notebook&#39;s
        <code>metadata</code> property. During decoding, a notebook&#39;s <code>title</code> is
        mapped directly to the article&#39;s <code>title</code> property.</p>
      <p>In <code>nbformat v4</code>, a notebook&#39;s <code>authors</code> property is an array of
        <code>any</code> type. Users can add an author as a string, or an object with more
        structured metadata on the author. During, decoding this codec will handle each author,
        based on the type of data:</p>
      <ul>
        <li>
          <p><code>string</code>s are decoded by the <a href="../person"><code>person</code>
              codec</a> into a <code>Person</code> node</p>
        </li>
        <li>
          <p><code>object</code>s are <code>coerce()</code>d to a <code>Person</code> node</p>
        </li>
      </ul>
      <p>This allows for some flexibility for users when entering metadata (e.g. using a string
        instead of an object, using <code>lastName</code> instead of <code>familyName</code>) while
        still ensuring that it is consistent with the schema.org vocabulary and Stencila schema. All
        other data in the notebook&#39;s <code>metadata</code> is stored in the article&#39;s
        <code>meta</code> property.</p>
      <p>For example, the following notebook,</p>
      <pre><code class="language-json">{
  &quot;nbformat&quot;: 4,
  &quot;nbformat_minor&quot;: 4,
  &quot;metadata&quot;: {
    &quot;title&quot;: &quot;Article title&quot;,
    &quot;authors&quot;: [
      &quot;Josiah Carberry PhD (http://library.brown.edu/about/hay/carberry.php)&quot;,
      &quot;Dr Jane Carberry &lt;jane.carberry@example.org&gt;&quot;,
      {
        &quot;firstName&quot;: &quot;Janet&quot;,
        &quot;lastName&quot;: &quot;Carberry&quot;,
        &quot;affiliations&quot;: {
          &quot;type&quot;: &quot;Organization&quot;,
          &quot;name&quot;: &quot;Brown University&quot;
        },
        &quot;favoriteColour&quot;: &quot;red&quot;
      }
    ],
    &quot;arbitrary_metadata&quot;: {
      &quot;provider&quot;: &quot;Deep Thought&quot;,
      &quot;answer&quot;: 42
    }
  },
  &quot;cells&quot;: []
}</code></pre>
      <p>is decoded to this <code>Article</code> with each author expanded to a <code>Person</code>
        node,</p>
      <pre><code class="language-json">{
  &quot;type&quot;: &quot;Article&quot;,
  &quot;title&quot;: &quot;Article title&quot;,
  &quot;authors&quot;: [
    {
      &quot;type&quot;: &quot;Person&quot;,
      &quot;givenNames&quot;: [&quot;Josiah&quot;],
      &quot;familyNames&quot;: [&quot;Carberry&quot;],
      &quot;honorificSuffix&quot;: &quot;PhD&quot;,
      &quot;url&quot;: &quot;http://library.brown.edu/about/hay/carberry.php&quot;
    },
    {
      &quot;type&quot;: &quot;Person&quot;,
      &quot;honorificPrefix&quot;: &quot;Dr&quot;,
      &quot;givenNames&quot;: [&quot;Jane&quot;],
      &quot;familyNames&quot;: [&quot;Carberry&quot;],
      &quot;emails&quot;: [&quot;jane.carberry@example.org&quot;]
    },
    {
      &quot;type&quot;: &quot;Person&quot;,
      &quot;affiliations&quot;: [
        {
          &quot;type&quot;: &quot;Organization&quot;,
          &quot;name&quot;: &quot;Brown University&quot;
        }
      ],
      &quot;familyNames&quot;: [&quot;Carberry&quot;],
      &quot;givenNames&quot;: [&quot;Janet&quot;]
    }
  ],
  &quot;meta&quot;: {
    &quot;arbitrary_metadata&quot;: {
      &quot;provider&quot;: &quot;Deep Thought&quot;,
      &quot;answer&quot;: 42
    }
  },
  &quot;content&quot;: []
}</code></pre>
      <h3 id="cells">Cells</h3>
      <p>The main content of a Jupyter Notebooks is in the <code>cells</code> array. These cells are
        of different types, the most commonly used types being <code>MarkdownCell</code> and
        <code>CodeCell</code>. All cells are decoded to nodes of type <code>BlockContent</code> in
        the <code>content</code> property of the <code>Article</code>.</p>
      <h4 id="etc"><code>MarkdownCell</code> etc</h4>
      <p><code>MarkdownCell</code>s are decoding to an array of <code>BlockContent</code> nodes e.g.
        <code>Heading</code>, <code>Paragraph</code> etc. This is done by simply delegating to the
        <a href="../md"><code>md</code> codec</a>; see there for more details on the Markdown syntax
        supported. At present, there is no special handling of the Markdown content, although that
        could be added if there was a need to handle Markdown syntax that was common in Jupyter
        Notebooks (e.g. variable interpolation using double braces <code>{{}}</code>).</p>
      <p>In <code>v3</code> of the Jupyter Notebook format there are also cells of type
        <code>HeadingCell</code>, and of type <code>MarkdownCell</code> with <code>cell_type</code>
        set to <code>html</code>. These are decoded in a similar way to standard
        <code>MarkdownCells</code> - by delegating to the <code>md</code> and <code>html</code>
        codecs respectively to decode them into <code>BlockContent</code> nodes.</p>
      <h4 id="-7"><code>CodeCell</code></h4>
      <p><code>CodeCell</code>s are decoded to a <code>CodeChunk</code>. The cell&#39;s
        <code>source</code> (<code>input</code> in <code>nbformat v3</code>) simply becomes the
        chunk&#39;s <code>text</code>. Properties of a cell that are not directly translatable e.g.
        <code>execution_count</code>, and any other data in the cell&#39;s <code>metadata</code>,
        are placed in the chunk&#39;s <code>meta</code> property.</p><span
        itemtype="https://schema.stenci.la/Array">['{ "cell_type": "code", "execution_count": 3,
        "metadata": {}, "source": [ "df.head()" ], "outputs": [ { "data": { "output_type":
        "execute_result", "text/html": [ "','\\n", "\\n", " \\n", " \\n", " \\n", " \\n", " \\n", "
        \\n", " \\n", " \\n", " \\n", " \\n", " \\n", " \\n", " \\n", " \\n",{ "type": "CodeChunk",
        "meta": { "execution_count": 3 }, "text": "df.head()", "outputs": [ { "type": "Table",
        "rows": [ { "type": "TableRow", "cells": [{ "cell_type": "code", "execution_count": 7,
        "metadata": {}, "source": [ "df.plot(x=\'YEAR\', y=\'SUNACTIVITY\', xlim=(1700,2008))" ],
        "outputs": [ { "output_type": "execute_result", "data": { "text/plain": [
        "',{type:'Table',rows:[{type:'TableRow',cells:[]},{type:'TableRow',cells:[{type:'TableCell',content:[{type:'Strong',content:['0']}]},{type:'TableCell',content:['
        1700']},{type:'TableCell',content:[' 5']}]},{type:'TableRow',cells:[]}]}]</span>
      <p>The decoding of a <code>CodeCell</code>&#39;s <code>outputs</code> is a little more
        involved. In both <code>v3</code> and <code>v4</code> of <code>nbformat</code> this is an
        array of outputs of different types. The type names differ by schema version. In
        <code>v4</code>, they are <code>ExecuteResult</code>, <code>DisplayData</code>,
        <code>Stream</code> and <code>Error</code>.</p>
      <p><code>ExecuteResult</code> and <code>DisplayData</code> outputs have a
        <code>MimeBundle</code> which provides the output of the code cell as one or more media
        types. The <code>ipynb</code> codec attempts to decode the raw content of a
        <code>MimeBundle</code> into a semantic <code>Node</code> in the Stencila schema. This
        allows outputs to be used in other code chunks, or encoded in other formats.</p>
      <p>For instance, if a cell outputs a HTML table then it will be decoded to a
        <code>Table</code> node, which could then later be encoded as a table in Markdown, Microsoft
        Word or JATS. For example, this <code>CodeCell</code> which outputs the head of a Pandas
        data frame as HTML,</p>
      <pre><code class="language-json">{
  &quot;cell_type&quot;: &quot;code&quot;,
  &quot;execution_count&quot;: 3,
  &quot;metadata&quot;: {},
  &quot;source&quot;: [
    &quot;df.head()&quot;
  ],
  &quot;outputs&quot;: [
    {
      &quot;data&quot;: {
        &quot;output_type&quot;: &quot;execute_result&quot;,
        &quot;text/html&quot;: [
          &quot;&lt;div style=\&quot;max-height:1000px;max-width:1500px;overflow:auto;\&quot;&gt;\n&quot;,
          &quot;&lt;table border=\&quot;1\&quot; class=\&quot;dataframe\&quot;&gt;\n&quot;,
          &quot;  &lt;thead&gt;\n&quot;,
          &quot;    &lt;tr style=\&quot;text-align: right;\&quot;&gt;\n&quot;,
          &quot;      &lt;th&gt;&lt;/th&gt;\n&quot;,
          &quot;      &lt;th&gt;YEAR&lt;/th&gt;\n&quot;,
          &quot;      &lt;th&gt;SUNACTIVITY&lt;/th&gt;\n&quot;,
          &quot;    &lt;/tr&gt;\n&quot;,
          &quot;  &lt;/thead&gt;\n&quot;,
          &quot;  &lt;tbody&gt;\n&quot;,
          &quot;    &lt;tr&gt;\n&quot;,
          &quot;      &lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;\n&quot;,
          &quot;      &lt;td&gt; 1700&lt;/td&gt;\n&quot;,
          &quot;      &lt;td&gt;  5&lt;/td&gt;\n&quot;,
          &quot;    &lt;/tr&gt;\n&quot;,
          &quot;    &lt;tr&gt;\n&quot;,</code></pre>
      <p>is decoded into a <code>CodeChunk</code> with a <code>Table</code> as output,</p>
      <pre><code class="language-json">{
  &quot;type&quot;: &quot;CodeChunk&quot;,
  &quot;meta&quot;: {
    &quot;execution_count&quot;: 3
  },
  &quot;text&quot;: &quot;df.head()&quot;,
  &quot;outputs&quot;: [
    {
      &quot;type&quot;: &quot;Table&quot;,
      &quot;rows&quot;: [
        {
          &quot;type&quot;: &quot;TableRow&quot;,
          &quot;cells&quot;: [</code></pre>
      <p>For image media types (e.g. <code>image/png</code>), the content is decoded to an
        <code>ImageObject</code>. The Python library <code>matplotlib</code> is often used in
        Jupyter Notebooks. When using <code>matplotlib</code>, there is usually text output like
        <code>&lt;matplotlib.axes.AxesSubplot at 0xada0550&gt;</code> as an
        <code>ExecuteResult</code> alongside the <code>DisplayData</code> containing the actual
        image. This output is treated as an artifact and is not decoded into a Stencila
        <code>Node</code>. For example, this Jupyter Notebook <code>CodeCell</code>,</p>
      <pre><code class="language-json">{
  &quot;cell_type&quot;: &quot;code&quot;,
  &quot;execution_count&quot;: 7,
  &quot;metadata&quot;: {},
  &quot;source&quot;: [
    &quot;df.plot(x=&#39;YEAR&#39;, y=&#39;SUNACTIVITY&#39;, xlim=(1700,2008))&quot;
  ],
  &quot;outputs&quot;: [
  {
    &quot;output_type&quot;: &quot;execute_result&quot;,
    &quot;data&quot;: {
      &quot;text/plain&quot;: [
        &quot;&lt;matplotlib.axes.AxesSubplot at 0xada0550&gt;&quot;
      ]
    },
    &quot;execution_count&quot;: 7,
    &quot;metadata&quot;: {},
  },
  {
    &quot;output_type&quot;: &quot;display_data&quot;,
    &quot;data&quot;: {
      &quot;image/png&quot;: &quot;iVBORw0KGgoAAAANSUhEUgAAAXYAAAEKCAYAAAAGvn7fAAAABH...&quot;</code></pre>
      <p>is decoded into this Stencila <code>CodeChunk</code> without the <code>matplotlib</code>
        text output:</p>
      <pre><code class="language-json">{
  &quot;type&quot;: &quot;CodeChunk&quot;,
  &quot;meta&quot;: {
    &quot;execution_count&quot;: 7
  },
  &quot;text&quot;: &quot;df.plot(x=&#39;YEAR&#39;, y=&#39;SUNACTIVITY&#39;, xlim=(1700,2008))&quot;,
  &quot;outputs&quot;: [
    {
      &quot;type&quot;: &quot;ImageObject&quot;,
      &quot;format&quot;: &quot;image/png&quot;,
      &quot;contentUrl&quot;: &quot;/tmp/ffbd2b7cdabce95b01e1f41834f90604.png&quot;
    }
  ]
}</code></pre>
      <p>The decoding of all other media types is delegated to other codecs by matching against
        their registered <code>mediaTypes</code> e.g. <code>text/html</code> is decoded by the
        <code>html</code> codec. For example, for <code>text/plain</code>, the <code>txt</code>
        codec is used which will decode to text to <code>null</code>, <code>boolean</code> and
        <code>number</code> nodes if possible.</p>
      <p>For <code>Stream</code> outputs, the output <code>text</code> is simply decoded to a
        <code>string</code> node.</p>
      <h2 id="encoding-3">Encoding</h2>
      <p>When encoding a Stencila <code>Node</code> to a Jupyter Notebook, if it is not an
        <code>Article</code>, then it is wrapped as necessary into an <code>Article</code>. Encoding
        then proceeds as pretty much the inverse of decoding.</p>
      <p>The area with the most asymetry between decoding and encoding, and the area with the
        greatest loss during round trip conversion, is <code>CodeCell</code> <code>outputs</code>.
        As explained above, this codec aims to infer a semantic node type from a
        <code>MimeBundle</code> (e.g. a <code>Table</code> from HTML) and ignores some content (e.g.
        <code>matplotlib</code> console output). There is no attempt to store either the raw content
        or the media types. Therefore, during encoding,</p>
      <ul>
        <li>
          <p><code>string</code> nodes are encoded as the <code>text</code> property of
            <code>StreamOutput</code></p>
        </li>
        <li>
          <p><code>ImageObject</code> nodes are encoded as <code>DisplayData</code> outputs</p>
        </li>
        <li>
          <p>all other nodes are encoded as <code>ExecuteResult</code> outputs.</p>
        </li>
      </ul>
      <p>After encoding, the contents of the generated notebook is validated against the
        <code>nbformat v4</code> JSON Schema.</p>
    </article>
  </body>

</html>